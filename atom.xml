<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>masterx0的个人博客</title>
  
  <subtitle>诛仙</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://masterx0.github.io/blog/"/>
  <updated>2020-07-05T14:45:36.715Z</updated>
  <id>https://masterx0.github.io/blog/</id>
  
  <author>
    <name>Allen Master</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Socket</title>
    <link href="https://masterx0.github.io/blog/2020/07/01/Socket/"/>
    <id>https://masterx0.github.io/blog/2020/07/01/Socket/</id>
    <published>2020-07-01T04:03:12.000Z</published>
    <updated>2020-07-05T14:45:36.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><hr><h1 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h1><ul><li>阻塞式IO<ul><li>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回</li></ul></li><li>非阻塞式IO<ul><li>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）</li></ul></li><li>IO多路复用(事件驱动式IO)<ul><li>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中</li></ul></li><li>信号驱动式IO<ul><li>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中</li></ul></li><li>异步IO<ul><li>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O</li></ul></li><li>区别</li></ul><p><img src="https://camo.githubusercontent.com/d89aed2ba6c5390aad0626b013c288d8849c4f39/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932383130353739315f332e706e67#align=left&amp;display=inline&amp;height=427&amp;margin=%5Bobject%20Object%5D&amp;originHeight=427&amp;originWidth=761&amp;status=done&amp;style=none&amp;width=761" alt></p><h1 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h1><ul><li>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll<ul><li>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持</li><li>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select</li><li>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接时使用epoll</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;Socket&quot;&gt;&lt;a href=&quot;#Socket&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="https://masterx0.github.io/blog/2020/07/01/HTTP/"/>
    <id>https://masterx0.github.io/blog/2020/07/01/HTTP/</id>
    <published>2020-07-01T04:01:34.000Z</published>
    <updated>2020-07-05T14:45:36.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><hr><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><hr><ul><li>URI(统一资源标识符): 包含 URL(统一资源定位符) 和 URN(统一资源名称)</li><li>请求和响应报文：</li></ul><p><img src="https://camo.githubusercontent.com/f48540e5efe054841d1aa19097666c4b35500c10/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f485454505f526571756573744d6573736167654578616d706c652e706e67#align=left&amp;display=inline&amp;height=221&amp;margin=%5Bobject%20Object%5D&amp;originHeight=221&amp;originWidth=656&amp;status=done&amp;style=none&amp;width=656" alt><br><img src="https://camo.githubusercontent.com/6ee5dc048dd39a9c4f9a180cee34c66b196a7c45/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f485454505f526573706f6e73654d6573736167654578616d706c652e706e67#align=left&amp;display=inline&amp;height=267&amp;margin=%5Bobject%20Object%5D&amp;originHeight=267&amp;originWidth=704&amp;status=done&amp;style=none&amp;width=704" alt></p><ul><li>HTTP方法<ul><li>GET 获取资源 安全 幂等</li><li>HEAD 获取报文头部 安全 幂等</li><li>POST 上次资源 不安全 不幂等</li><li>PUT 修改资源 不安全 幂等</li><li>PATCH 部分修改资源 不安全 幂等</li><li>DELETE 删除资源 不安全 幂等</li><li>OPTIONS 查看资源支持的方法类型 安全 幂等</li></ul></li><li>HTTP状态码<ul><li>1XX 信息<ul><li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</li></ul></li><li>2XX成功<ul><li>200 Success：OK</li><li>204 No Content：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用</li></ul></li><li>3XX重定向<ul><li>301 Moved Permanently ：永久性重定向</li><li>302 Found ：临时性重定向</li></ul></li><li>4XX客户端错误<ul><li>400 Bad Request：请求报文中存在语法错误</li><li>401 Unauthorized：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）</li><li>403 Forbidden ：请求被拒绝</li><li>404 Not Found</li></ul></li><li>5XX服务端错误<ul><li>500 Internal Server Error ：服务器正在执行请求时发生错误</li><li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li></ul></li></ul></li><li>连接管理<ul><li>短连接和长连接(只需要建立一次 TCP 连接就能进行多次 HTTP 通信)：<ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。</li></ul></li><li>流水线：<ul><li>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</li></ul></li></ul></li><li>Cookie<ul><li>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息</li><li>用途：<ul><li>会话状态管理</li><li>个性化设置</li><li>浏览器行为跟踪</li></ul></li><li>创建过程<ul><li>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中</li><li>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器</li></ul></li></ul></li><li>Session<ul><li>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。使用 Session 维护用户登录状态的过程如下：<ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作</li></ul></li><li>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式</li></ul></li><li>Cookie与Session的选择<ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中</li></ul></li><li>代理<ul><li>代理服务器接受客户端的请求，并且转发给其它服务器</li><li>使用代理的主要目的：<ul><li>缓存</li><li>负载均衡</li><li>网络访问控制</li><li>访问日志记录</li></ul></li><li>代理服务器分为正向代理和反向代理两种：<ul><li>用户察觉得到正向代理的存在</li><li>而反向代理一般位于内部网络中，用户察觉不到</li></ul></li></ul></li></ul><hr><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><hr><ul><li>HTTP 有以下安全性问题：<ul><li>使用明文进行通信，内容可能会被窃听</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装</li><li>无法证明报文的完整性，报文有可能遭篡改</li></ul></li><li>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</li></ul><hr><h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><hr><ol><li>对称密钥加密：加密和解密使用同一密钥</li><li>非对称密钥加密：加密使用公钥，解密使用私钥</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HT
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://masterx0.github.io/blog/2020/06/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://masterx0.github.io/blog/2020/06/25/计算机网络/</id>
    <published>2020-06-25T06:12:14.000Z</published>
    <updated>2020-07-05T14:45:36.719Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><hr><h2 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h2><ul><li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li><li>对等（P2P）：不区分客户和服务器。<h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><ol><li>电路交换：电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。</li><li>分组交换：每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。<h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2>总时延 = (排队时延 + 处理时延 + 传输时延)(路由器中) + 传播时延(路由器间)</li><li>排队时延：分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</li><li>处理时延：主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</li><li>传输时延：主机或路由器传输数据帧所需要的时间。</li><li>传播时延：电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2></li><li>五层协议<hr><ul><li>应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。<ul><li>DNS：域名系统是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性</li><li>FTP：文件传送协议使用 TCP 进行连接，它需要两个连接来传送一个文件：<ul><li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li>数据连接：用来传送一个文件数据。根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：<pre><code>- 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。要求服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</code></pre></li></ul></li><li>DHCP：动态主机配置协议提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。使用的端口号为67/68，传输层协议为UDP。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</li><li>TELNET：远程登录协议用于登录到远程主机上，并且远程主机上的输出也会返回。使用的端口号为23，传输层协议为TCP。</li><li>电子邮件协议：包含发送协议和读取协议，发送协议常用 SMTP(使用的端口号为25，传输层协议为TCP)，读取协议常用 POP3(使用的端口号为110，传输层协议为TCP) 和 IMAP(使用的端口号为143，传输层协议为TCP)。</li></ul></li></ul><hr><ul><li>传输层：为进程提供通用数据传输服务，运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。<ul><li>UDP和TCP的特点：<ul><li>用户数据报协议UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文支持一对一、一对多、多对一和多对多的通信</li><li>传输控制协议TCP是面向连接的、提供可靠交付，有超时重传、滑动窗口、拥塞控制、流量控制，提供面向字节流的一对一的全双工通信</li></ul></li><li>TCP的三次握手：<ol><li>首先服务器端S处于LISTENH状态，等待来自客户端C的连接请求</li><li>C向S发送连接请求报文，SYN=1，ACK=0，选择一个初始的序列号X</li><li>S收到C收到连接请求报文，如果同意建立连接，则向C发送连接确认报文，SYN=1，ACK=1，确认号为X+1，同时也选择一个初始的序号Y</li><li>C收到S的连接确认报文后，还要向S发出确认，确认号为Y+1，序号为X+1</li><li>S收到C的确认后，连接建立</li></ol></li><li>三次握手的原因：发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</li><li>TCP的四次挥手：<ol><li>客户端C发送连接释放报文，FIN=1</li><li>服务端S收到请求后发出确认，进入CLOSE-WAIT 状态，此时TCP属于半关闭状态，服务端S可以继续向客户端C发送数据但是发过来不行</li><li>当服务端S不再需要连接时，发送连接释放报文，FIN=1</li><li>C收到后发出确认，进入TIME-WAIT状态，等待2MSL后释放连接</li><li>S收到C的确认后释放连接</li></ol></li><li>四次挥手的原因：客户端收到服务端发送的FIN报文后还需要等待2MSL时间，确保最后一个报文能够到达。因为如果服务端没有收到客户端的确认报文，那么就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况的发生；同时也是为了让本连接持续时间内产生的所有报文从网络中消失，使得下次连接不会出现旧的连接请求报文</li><li>TCP的拥塞控制：<ol><li>慢开始与拥塞避免：<ul><li>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</li><li>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1</li><li>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始</li></ul></li><li>快重传与快恢复：<ul><li>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认</li><li>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3</li><li>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免</li><li>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh</li></ul></li></ol></li></ul></li></ul><hr><ul><li>网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。<ul><li>与 IP 协议配套使用的还有三个协议：<pre><code>- 地址解析协议 ARP（Address Resolution Protocol）- 网际控制报文协议 ICMP（Internet Control Message Protocol）- 网际组管理协议 IGMP（Internet Group Management Protocol）</code></pre></li><li>地址解析协议ARP:<pre><code>- 网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变- ARP 实现由 IP 地址得到 MAC 地址</code></pre></li><li>网际控制报文协议ICMP<pre><code>- Ping是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性- Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径</code></pre></li></ul></li></ul><hr><ul><li>数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。<ul><li>信道分类：<ol><li>广播信道：一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</li><li>点对点信道：一对一通信。因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</li></ol></li><li>信道复用技术：<ol><li>频分复用：所有主机在相同的时间占用不同的频率带宽资源</li><li>时分复用：所有主机在不同的时间占用相同的频率带宽资源</li><li>统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送</li><li>波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波</li></ol></li><li>CSMA/CD(载波监听多点接入 / 碰撞检测)协议：<ul><li>多点接入：说明这是总线型网络，许多主机以多点的方式连接到总线上</li><li>载波监听：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待</li><li>碰撞检测：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞</li></ul></li><li>PPP协议：互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议</li><li>MAC地址：MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址</li><li>局域网：局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。可以分为星型、环形和直线型等。</li><li>以太网：以太网是一种星型拓扑结构局域网。使用交换机进行连接，交换机是一种链路层设备，它不会发生碰撞，能根据MAC地址进行存储转发。</li><li>交换机：交换机具有自学习能力，学习的是交换表的内容，交换表中存储着MAC地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</li><li>虚拟局域网：VLAN可以建立与地理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</li></ul></li></ul><hr><ul><li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。<ul><li>通信方式：单向通信、半双工通信、全双工通信</li><li>带通调制：模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号</li></ul></li></ul><hr></li><li>TCP/IP协议<ul><li>只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</li><li>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。<h2 id="WEB页面请求过程"><a href="#WEB页面请求过程" class="headerlink" title="WEB页面请求过程"></a>WEB页面请求过程</h2></li></ul></li><li>DHCP配置主机信息<ul><li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li><li>主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的UDP保温段中。</li><li>该报文段被放入一个具有广播IP目的地址(255.255.255.255)和源IP地址(0.0.0.0)的IP数据报中。</li><li>该数据报被放置在MAC帧中，具有目的地址FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</li><li>连接在交换机的DHCP服务器收到广播帧后，不断向上分解得到IP数据报、UDP报文段、DHCP请求报文，之后生成DHCP ACK报文，该报文含有以下信息：<pre><code>- IP地址- DNS服务器的IP地址- 默认网关路由器的IP地址和子网掩码</code></pre></li><li>DHCP ACK报文被放入UDP报文段中，UDP报文段被放入IP数据报中，最后放入MAC帧中。该帧的目的地址是请求主机的MAC地址，因为交换机具有自学习能力，之前发送了广播帧之后就记录了MAC地址到其转发接口的交换表项，因此交换机可以知道应该向哪个接口发送该MAC帧</li><li>主机收到该帧后不断分解得到DHCP报文，之后配置其IP地址、子网掩码和DNS服务器IP地址，并在其IP转发表中安装默认网关</li></ul></li><li>ARP解析MAC地址<ul><li>主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求。为了生成该套接字，主机需要知道网站域名对应的IP地址</li><li>主机生成一个DNS查询报文，该报文端口号为53</li><li>该报文被放入目的地址为DNS的IP地址的IP数据报中</li><li>为了获取IP数据报目的地址对应的MAC地址，需要使用ARP协议</li><li>主机生成一个包含目的地址为网关路由器IP地址的ARP查询报文，将该报文放入一个具有广播目的地址(FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送该帧，交换机再将该帧转发给所有连接设备</li><li>网关路由器接收到该帧后，不断向上解析到ARP报文，发现其中的IP地址与其接口的IP地址相符，于是发送ARP 响应报文，包含了它的MAC地址给主机</li></ul></li><li>DNS解析域名<ul><li>网关路由器接收到包含DNS查询报文的MAC帧后，抽取出IP数据报，并根据转发表决定应该转发的路由器</li><li>到达DNS服务器后，DNS服务器抽取出查询报文后在数据库查到待解析域名后发送响应报文</li><li>响应报文放入UDP报文段中，然后放入IP数据报中，通过路由器回传到网关路由器，并经由交换机到达主机</li></ul></li><li>HTTP请求页面<ul><li>在获取到HTTP服务器的IP地址后，通过三次握手建立TCP连接</li><li>HTTP服务器从TCP套接字读取报文后生成响应报文，将WEB页面内容发入到报文主体中返回给主机</li><li>浏览器收到HTTP响应报文后，抽取WEB页面内容进行渲染展示</li></ul></li></ol></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="interview" scheme="https://masterx0.github.io/blog/categories/interview/"/>
    
    
      <category term="网络基础" scheme="https://masterx0.github.io/blog/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统</title>
    <link href="https://masterx0.github.io/blog/2020/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://masterx0.github.io/blog/2020/06/22/计算机操作系统/</id>
    <published>2020-06-22T06:40:33.000Z</published>
    <updated>2020-07-05T14:45:36.719Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h1 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h1><hr><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ol><li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li><li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li><li>操作系统通过引入进程和线程，使得程序能够并发运行。<h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2></li><li>共享是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。</li><li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。<h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2></li><li>虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</li><li>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li><li>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li></ol><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><hr><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul><li>进程</li></ul><p>进程是资源分配的基本单位。</p><ul><li>线程</li></ul><p>线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。</p><ul><li>区别</li></ul><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><ul><li>临界区</li></ul><p>对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure><p></p><ul><li>同步与互斥<ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul></li><li><p>信号量</p><ul><li>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。<ul><li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul></li><li>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</li><li>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2>进程同步与进程通信很容易混淆，它们的区别在于：</li></ul></li><li><p>进程同步：控制多个进程按一定顺序执行；</p></li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><ol><li>管道，具有以下限制：<ul><li>只支持半双工通信（单向交替传输）；</li><li>只能在父子进程或者兄弟进程中使用。</li></ul></li><li>命名管道(FIFO)，去除了管道只能在父子进程中使用的限制</li><li>消息队列，相比于 FIFO，消息队列具有以下优点：<ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul></li><li>信号量，是一个计数器，用于为多个进程提供对共享数据对象的访问。</li><li>套接字(socket)，与以上通信机制不同的是，它可用于不同机器间的进程通信。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;基本特征&quot;&gt;&lt;a href=&quot;#基本特征&quot; class=&quot;headerlink&quot; title=&quot;基本
      
    
    </summary>
    
      <category term="interview" scheme="https://masterx0.github.io/blog/categories/interview/"/>
    
    
      <category term="操作系统" scheme="https://masterx0.github.io/blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>四月总结</title>
    <link href="https://masterx0.github.io/blog/2019/04/08/%E5%9B%9B%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>https://masterx0.github.io/blog/2019/04/08/四月总结/</id>
    <published>2019-04-08T01:32:02.000Z</published>
    <updated>2020-07-05T14:45:36.719Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h1 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h1><ul><li>上周四与@niwei和@ymx就南京分公司未来发展做了交流，目前是两种解决方案，一种是留在南京公司工作但是未来不做任何保障，随时可能失业；另一种是进入阿里base杭州但是难度较大，比较不现实。</li><li>自己思量了目前的状况，在手头有深圳中厂保底offer的前提下，应该自己继续找工作，而不是随遇而安在舒适圈里打发时间搬砖。</li><li>在互联网大厂基本没有hc的情况下再想进去很难，转变方向目标瞄准初创企业小厂，范围南京、杭州和上海。<h1 id="简历投递记录"><a href="#简历投递记录" class="headerlink" title="简历投递记录"></a>简历投递记录</h1></li><li>A2-9-107</li><li>alibaba(HZ)</li><li>bytedance(NJ) 4.14面试</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;未来规划&quot;&gt;&lt;a href=&quot;#未来规划&quot; class=&quot;headerlink&quot; title=&quot;未来
      
    
    </summary>
    
      <category term="alicloud" scheme="https://masterx0.github.io/blog/categories/alicloud/"/>
    
    
      <category term="月度会议总结" scheme="https://masterx0.github.io/blog/tags/%E6%9C%88%E5%BA%A6%E4%BC%9A%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>库存中心学习笔记.md</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/%E5%BA%93%E5%AD%98%E4%B8%AD%E5%BF%83%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/库存中心学习笔记/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.719Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h2 id="基础架构设计"><a href="#基础架构设计" class="headerlink" title="基础架构设计"></a>基础架构设计</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1546505877718-acdff64e-23f9-4cb0-8459-8f87d0774ec3.png" alt="基础架构图"></p><h2 id="WHC仓库中心-amp-IPM库存中心"><a href="#WHC仓库中心-amp-IPM库存中心" class="headerlink" title="WHC仓库中心&amp;IPM库存中心"></a>WHC仓库中心&amp;IPM库存中心</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1546579446520-fb80aaa5-4f8f-4139-811c-9c11f70c6df2.png" alt="项目结构"></p><h2 id="库存相关"><a href="#库存相关" class="headerlink" title="库存相关"></a>库存相关</h2><p>可售库存(sellable quantity) = 真实库存(real quantity) + 在途库存(preorder quantity) - 锁定库存(withhold quantity) - 占用库存(occupy quantity) - 安全库存(safe_quantity 后续会变更)<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1546409130828-ff9d66aa-da69-4f89-8004-87ad22ae45ec.png" alt="下单链路"><br>库存管理关键功能有库存锁定(PreOrder)、占用、确认和取消，库存查询以及库存调整。</p><ul><li>标准流程是：锁定-&gt;占用-&gt;确认-&gt;扣减，取消在锁定和占用时都可以调用</li><li>库存查询分为：单个sku某个仓库库存查询、单个sku所有仓库总量查询、仓库所有sku分页查询</li><li>库存调整分为：创建或增量修改库存、创建或覆盖修改库存。两者流程区别在于插入数据库时前者使用单线程insert、后者使用多线程insert<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><strong>库存相关表</strong>：<br>inventory、inventory_event、inventory_log<br>其中event表：安全库存调整、物理库存调整、PO调整、锁定/占用/取消/扣减；log表：在发生上面的事件后，记录下来当时更多的信息，比如仓库信息等<br><strong>渠道库存相关表</strong>：<br>channel、channel_inventory、channel_entity、channel_inventory_log<br><strong>仓库相关表</strong>：<br>warehouse、warehouse_rule、warehouse_scope<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1546410786676-f1ebece9-5511-4216-955e-6ee60b58e368.png" alt="数据库表相关"><br>在阅读项目wiki时备注不使用悲观锁，采用乐观锁（版本号判断）应该是由于库存相关业务查多改少的缘故。<h2 id="缓存设置"><a href="#缓存设置" class="headerlink" title="缓存设置"></a>缓存设置</h2></li><li>寻源时设置地址到编码映射缓存，key为warehouseScope中的四级地址，value为对应的warehouseCodes</li><li>拿到warehouseCodes后，要找到对应的warehouse，此处设置一个缓存，key为 warehouseCode，vaule为warehouse</li><li>寻源的时候，会有对应商品的skuId，以商品的skuId和对应warehouseCode，warehouseType 作为key，inventory 作为value</li><li>寻源的时候，还需要找出对应skuId 最大可买数量，对这部分数据也做缓存，key 为skuId， value 为数量<br>在Read相关操作时设置缓存、在Write相关操作时删除缓存<h2 id="渠道库存相关"><a href="#渠道库存相关" class="headerlink" title="渠道库存相关"></a>渠道库存相关</h2>渠道库存主要有两种应用场景，其一是库存第三方渠道管理(如京东、苏宁易购、自营电商等)，另一是商家或平台营销活动管理(限购、秒杀、预售等)<br><em>运营端</em>：<br>库存管理员可以创建渠道、变更渠道库存、查询渠道库存等；<br><em>商家端</em>：<br>交易相关库存锁定、库存占用、库存扣减等。<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1546499617980-78e6368d-49c5-4473-a1d6-b9c342f851db.png" alt="渠道库存表关系"><br>主要接口如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">createChannelInventory：创建渠道库存。平台设定渠道可售卖库存或商家参加平台活动，传入渠道信息以及库存信息创建渠道库存，不需要对渠道库存进行库存可用数量校验(渠道不是实时生效，存在先创建渠道库存后入库的场景)。</span><br><span class="line">batchCreateChannelInventory：批量创建渠道库存。场景同 创建渠道库存。</span><br><span class="line">batchCreateChannelInventoryWithChannel：创建渠道并批量创建渠道库存。商家创建活动并发布后，传入活动渠道信息以及库存信息创建渠道库存，不需要校验可用库存数。</span><br><span class="line">incChannelInventory：增量调整渠道库存。对应渠道商品入库或增量划分库存给指定渠道时，传入渠道信息以及库存信息在原有渠道库存基础上增量调整渠道库存数量。</span><br><span class="line">setChannelInventory：全量覆盖渠道库存。重新设定渠道库存数量时，传入渠道信息以及库存信息直接覆盖原有渠道库存数量。</span><br><span class="line">releaseChannelInventory：释放渠道库存。对应sku退出渠道销售或商家sku退出平台活动时，传入渠道信息以及sku信息释放对应渠道库存，释放后，已经产生的订单操作导致的库存操作正常进行，下单时该sku禁止通过该渠道下单。</span><br><span class="line">batchReleaseChannelInventories：批量释放渠道库存。场景同 释放渠道库存。</span><br><span class="line">releaseByChannel：释放对应渠道下所有的渠道库存。当渠道失效时，传入渠道信息，批量释放该渠道下所有渠道库存。</span><br><span class="line">queryChannelInventory：查询sku的渠道库存。传入sku信息(支持指定渠道，需传入渠道信息)查询渠道库存数据。</span><br><span class="line">queryAllSkuInventory：查询渠道下所有的渠道库存。传入渠道编码，获取该渠道下所有的渠道库存。</span><br><span class="line">findNeedInvalidChannel：获取已经失效但是有部分渠道库存未释放的渠道。提供给任务中心调用，用于补偿任务，补偿释放需要释放的渠道库存。</span><br><span class="line">findNeedExpiredChannelByDateTime：获取需要失效的渠道数据。提供给任务中心调用，用户自动释放过期渠道。</span><br><span class="line">channelInventoryPagination：渠道库存分页，分页展示渠道库存，支持渠道编码以及sku唯一标识（skuId或skuCode）查询。</span><br><span class="line">queryChannelInventory：根据渠道信息、sku信息、仓库信息查询渠道库存。海信接口，库存中心后续迭代支持。</span><br><span class="line">queryActivityChannelInventory：根据渠道信息以及sku信息查询生效的渠道库存。海信接口。</span><br><span class="line">queryChannelInventoryWithWarehouse：根据渠道信息、sku信息、仓库信息、状态（选填）查询渠道库存。海信接口，已存在类似能力接口，后续迭代合并。</span><br><span class="line">queryChannelInventoryList：根据sku信息、仓库信息、状态（选填）查询渠道库存。海信接口，已存在类似能力接口，后续迭代合并。</span><br></pre></td></tr></table></figure></li></ul><p>PS:其中需要注意创建渠道当传入渠道sid时要做幂等性处理，未传入则不需要；同时对创建但未使用的渠道建立定时cron任务清除;渠道库存创建时，不对库存数据进行操作，仅仅只是在库存的基础上增加了一级渠道库存;存在独占渠道库存时，在创建其他渠道库存时获取剩余可用库存，需要扣除独占部分的库存;</p><h2 id="寻源【重要】"><a href="#寻源【重要】" class="headerlink" title="寻源【重要】"></a>寻源【重要】</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1546419671692-69c3de18-194b-48d7-b4ac-dec5d3d5cf23.png" alt="sourcing模型"><br>核心逻辑如下：<br>参数校验-&gt;加载寻源规则-&gt;组装组合商品-&gt;核心寻源模型运算-&gt;针对不同业务合并仓库-&gt; 过滤择优仓库<br>寻源是库存中心最为重要的一部分，需要梳理寻源代码结构、主要执行流程、对应的派单规则和拆单规则<br><a href="https://yuque.antfin-inc.com/wb-xxy406417/hsmsiu/fqyxme" target="_blank" rel="noopener">寻源模块具体细节</a></p><h2 id="仓库模型"><a href="#仓库模型" class="headerlink" title="仓库模型"></a>仓库模型</h2><p><a href="https://yuque.antfin-inc.com/cnwmsinventory/ndwb5k/kby1ss" target="_blank" rel="noopener">菜鸟库存模型</a>从仓库内的一二三级帐和whc的库存帐转变为以基础网络库存，逻辑库存，物理库存为核心的三层库存体系<img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1550657154639-2bad6c33-4d7b-4500-805e-1bab93d1bf21.png" alt="qimen"> 临保库存、<a href="https://yuque.antfin-inc.com/wb-xxy406417/hsmsiu/rbt1ay" target="_blank" rel="noopener">批次库存</a>在Marathon迭代一种做了，热点库存、预设库存等目前在调研阶段尚未落地</p><h2 id="库存流水"><a href="#库存流水" class="headerlink" title="库存流水"></a>库存流水</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1546587720879-cd453bf1-e06d-4a2c-961d-16b557f51c3e.png" alt="用例图"><br>主要由report_inventory_log表内容体现，通过定时任务定期汇总周期内平均库存、日均销售成本、库存周转天数，提供分页查询接口供指标数据查询</p><h2 id="管控中心"><a href="#管控中心" class="headerlink" title="管控中心"></a>管控中心</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1546588389356-14e005e8-8104-4855-906d-1c042854a7a4.png" alt="monitor表设计"><br>数据流如下所示：<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1547430315667-604e1cb1-e0e9-4db2-ad8d-86e99cf176b7.png" alt="dataflow"><br>监控来源:外部将相关数据传入管控中心，由管控中心根据特定规则对这些业务数据进行分析，得出是否存在问题，传入渠道包括如下：</p><ul><li>提供基础的DUBBO服务，对外暴露接收需要监控的业务数据</li><li>提供MQ异步消息通信，目前支持RocketMQ和ONS，各自提供对应的topic和tag，最终结果还是调用上面提供的DUBBO接口<br>以使用MQ接受topic为例，通过MQDataSourceReceiver接受数据，使用MonitorBizDataWriteFacde.initMonitorData()初始化管控数据，再通过ActionChain.new flowControl()新建处理流，通过一系列例如ValidateAction、ConvertAction、DataDBAction处理后返回MonitorResult</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;基础架构设计&quot;&gt;&lt;a href=&quot;#基础架构设计&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>三月总结</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/%E4%B8%89%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/三月总结/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h1 id="3-1会议-zhenqing表示东购项目是未来南京研发中心的主要方向"><a href="#3-1会议-zhenqing表示东购项目是未来南京研发中心的主要方向" class="headerlink" title="3.1会议@zhenqing表示东购项目是未来南京研发中心的主要方向"></a>3.1会议@zhenqing表示东购项目是未来南京研发中心的主要方向</h1><p>lazada供应链和仓储配送内容</p><h1 id="3-4会议-niwei强调业务理解与技术成长一样重要"><a href="#3-4会议-niwei强调业务理解与技术成长一样重要" class="headerlink" title="3.4会议@niwei强调业务理解与技术成长一样重要"></a>3.4会议@niwei强调业务理解与技术成长一样重要</h1><p>sourcing逻辑梳理</p><h1 id="3-5会议指出接下来两到三周内要多阅读理解关于仓储配送、履约跟踪的内容"><a href="#3-5会议指出接下来两到三周内要多阅读理解关于仓储配送、履约跟踪的内容" class="headerlink" title="3.5会议指出接下来两到三周内要多阅读理解关于仓储配送、履约跟踪的内容"></a>3.5会议指出接下来两到三周内要多阅读理解关于仓储配送、履约跟踪的内容</h1><p>物流的细分环节(从下单购买到收货之间发生了什么)</p><h1 id="3-6会议-yumin分享了配送中心业务相关调研成果"><a href="#3-6会议-yumin分享了配送中心业务相关调研成果" class="headerlink" title="3.6会议@yumin分享了配送中心业务相关调研成果"></a>3.6会议@yumin分享了配送中心业务相关调研成果</h1><p>东购仓配分为上海主仓、北京和武汉分仓；配送分为正常配送、直配送、供应商配送和调拨配送<br>@niwei着重强调物流的业务理解重要性(配送平台)，解释物流宝定位</p><h1 id="3-8会议对菜鸟仓配做了分享"><a href="#3-8会议对菜鸟仓配做了分享" class="headerlink" title="3.8会议对菜鸟仓配做了分享"></a>3.8会议对菜鸟仓配做了分享</h1><p>仓储+配送是重点</p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>阿里技术分级<br>P5 开发工程师<br>P6 高级开发工程师<br>P7 技术专家<br>P8 高级专家<br>P9 资深技术专家</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;3-1会议-zhenqing表示东购项目是未来南京研发中心的主要方向&quot;&gt;&lt;a href=&quot;#3-1会
      
    
    </summary>
    
      <category term="alicloud" scheme="https://masterx0.github.io/blog/categories/alicloud/"/>
    
    
      <category term="月度会议总结" scheme="https://masterx0.github.io/blog/tags/%E6%9C%88%E5%BA%A6%E4%BC%9A%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>仓储配送领域知识总结.md</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/%E4%BB%93%E5%82%A8%E9%85%8D%E9%80%81%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/仓储配送领域知识总结/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><p>仓储库存作为全渠道零售的底层核心支撑业务，服务于整个交易链路，承担十分重要的作用。在学习公司已有parana_inventory以及集团内部包含盒马、菜鸟、物流宝等产品的系统框架基础知识后，对库存业务有了些许认识，现在记录如下以便纠错备忘和供团队分享时所用。</p><hr><p><a name="f8379536"></a></p><h1 id="1-parana-inventory目前内容理解"><a href="#1-parana-inventory目前内容理解" class="headerlink" title="1.parana_inventory目前内容理解"></a>1.parana_inventory目前内容理解</h1><p>截止<em>v5.0.18.1.RELEASE</em>版本_，_目前公司内部库存中心主要实现了IPM基础功能，分为仓库、库存和渠道三个模块，其中仓库模块内由于和WMS关系密切，目前仅提供包含覆盖范围设置在内的仓库基础信息维护功能；库存模块内面向交易链路包含库存占用、锁定、取消、扣减、查询和调整在内的库存基础操作较为成熟，库存流水(帐)、在途库存、批次库存和库存同步等功能有待改进；渠道模块拟形成独占渠道、互斥渠道、活动渠道和共享渠道在内的模型。<br><a name="744b806f"></a></p><h1 id="2-众配宝"><a href="#2-众配宝" class="headerlink" title="2.众配宝"></a>2.众配宝</h1><p><a name="8e1b944f"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>解决最后一公里问题，定位服务于B2C业务模式，重点聚焦末端的降本提效，提升配送服务品质和小件员管理能力<br><a name="76cefffa"></a></p><h2 id="业务设计"><a href="#业务设计" class="headerlink" title="业务设计"></a>业务设计</h2><p>主要涵盖从站点接单到货、领货扫描、小件员领货根据情况完成包裹配送/拒收/滞留等派件业务、退货出站、中转出站。<br><a name="80d24a2a"></a></p><h2 id="借鉴意义"><a href="#借鉴意义" class="headerlink" title="借鉴意义"></a>借鉴意义</h2><p>由于东购在配送环节需要cover支付业务，这块有待商榷<br>参考资料<a href="https://yuque.antfin-inc.com/attachments/lark/0/2019/pdf/124729/1552036366627-d2863a90-d53f-47a8-acdc-16cddf1bd3ba.pdf?_lake_card=%7B%22uid%22%3A%22rc-upload-1552034959446-3%22%2C%22src%22%3A%22https%3A%2F%2Fyuque.antfin-inc.com%2Fattachments%2Flark%2F0%2F2019%2Fpdf%2F124729%2F1552036366627-d2863a90-d53f-47a8-acdc-16cddf1bd3ba.pdf%22%2C%22name%22%3A%22%E8%8F%9C%E9%B8%9F%E4%BC%97%E9%85%8D%E5%AE%9D%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97.pdf%22%2C%22size%22%3A5309526%2C%22type%22%3A%22application%2Fpdf%22%2C%22ext%22%3A%22pdf%22%2C%22progress%22%3A%7B%22percent%22%3A0%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22card%22%3A%22file%22%7D" target="_blank" rel="noopener">菜鸟众配宝操作指南.pdf</a><br><a name="9ade249f"></a></p><h1 id="3-物流宝"><a href="#3-物流宝" class="headerlink" title="3.物流宝"></a>3.物流宝</h1><p><a name="8e1b944f-1"></a></p><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p><a name="3882d731"></a></p><h3 id="物流宝业务"><a href="#物流宝业务" class="headerlink" title="物流宝业务"></a>物流宝业务</h3><p>2011年年初，阿里的物流信息管理系统“物流宝”正式推出。“物流宝”本质上也是一个物流信息调配平台，阿里将第三方快递、仓储的信息接入进来，面向淘宝卖家提供入库、发货、上门揽件等服务。“物流宝”的关键在于通过数据化分析追踪各地物流资源使用情况，减少货物在各地间的流转以达到降低成本和提高效率的目的，用于沟通买家、卖家和第三方供应商实现买家优质物流服务体验、卖家多样化物流解决方案和3PL高效物流协同的平台<br><a name="e7bcc8db"></a></p><h3 id="物流宝与菜鸟仓储区别"><a href="#物流宝与菜鸟仓储区别" class="headerlink" title="物流宝与菜鸟仓储区别"></a>物流宝与菜鸟仓储区别</h3><p>物流宝核心在于物流仓储资源的数据化分析和管理能力，调配第三方物流资源，建立服务平台、履约平台、跟踪平台、仓储平台和配送平台形成服务网络和运营网络，在集团内部物流宝又称“天网”。<br>菜鸟仓储网络核心主要在于建设仓储设施网络，通过社会化协同的方式形成一张覆盖全国的仓配智能骨干网，主要由快递网络、仓配网络和末端网络(例如菜鸟驿站)组成，在集团内部菜鸟网络又称“地网”。<br><a name="3c59d067"></a></p><h2 id="物流宝API接入"><a href="#物流宝API接入" class="headerlink" title="物流宝API接入"></a>物流宝API接入</h2><p>物流宝提供的API经过整理主要可以分为面向商品、订单、库存和其他相关这几类，调用方式是通过http接口post方式<a href="https://open.taobao.com/api.htm?docId=10597&amp;docType=2" target="_blank" rel="noopener">https://open.taobao.com/api.htm?docId=10597&amp;docType=2</a></p><table><thead><tr><th></th><th>接口名</th><th>接口简介</th><th>接口描述</th></tr></thead><tbody><tr><td><br><br><br><br><br><br><br><br>商品</td><td>taobao.wlb.item.get</td><td>根据商品ID获取商品信息</td><td>根据商品ID获取商品信息,除了获取商品信息外还可获取商品属性信息和库存信息</td></tr><tr><td></td><td>taobao.wlb.item.map.get</td><td>根据商品ID查询商品映射关系</td><td>根据物流宝商品ID查询商品映射关系</td></tr><tr><td></td><td>taobao.wlb.item.combination.get</td><td>根据商品id查询商品组合关系</td><td></td></tr><tr><td></td><td>taobao.wlb.item.update</td><td>修改物流宝商品信息</td><td></td></tr><tr><td></td><td>taobao.wlb.item.add</td><td>添加单个物流宝商品</td><td></td></tr><tr><td></td><td>taobao.wlb.item.query</td><td>分页查询商品</td><td>根据状态、卖家、SKU等信息查询商品列表</td></tr><tr><td></td><td>taobao.wlb.item.batch.query</td><td>批次库存查询接口</td><td>根据用户id，item id list和store code来查询商品库存信息和批次信息</td></tr><tr><td><br><br><br><br><br><br><br><br><br><br><br>订单</td><td>taobao.wlb.order.page.get</td><td>分页查询物流宝订单</td><td></td></tr><tr><td></td><td>taobao.wlb.wlborder.get</td><td>根据物流宝订单编号查询物流宝订单概要信息</td><td></td></tr><tr><td></td><td>taobao.wlb.order.consign</td><td>订单已发货通知接口</td><td>当物流宝订单已发货的时候，erp需要调用该接口来通知物流订单和淘宝交易订单已发货<br></td></tr><tr><td></td><td>taobao.wlb.order.create</td><td>创建物流宝订单</td><td>创建物流宝订单，由外部ISV或者ERP，Elink，淘宝交易产生</td></tr><tr><td></td><td>taobao.wlb.order.cancel</td><td>取消物流宝订单</td><td></td></tr><tr><td></td><td>taobao.wlb.orderdetail.date.get</td><td>按照日期范围查询物流订单详情</td><td>外部ERP可通过该接口查询一段时间内的物流宝订单，以及订单详情</td></tr><tr><td></td><td>taobao.wlb.orderstatus.get</td><td>物流宝订单流转状态查询</td><td>根据物流宝订单号查询物流宝订单至目前为止的流转状态列表</td></tr><tr><td></td><td>taobao.wlb.tradeorder.get</td><td>根据交易号获取物流宝订单</td><td>根据交易类型和交易id查询物流宝订单详情</td></tr><tr><td></td><td>taobao.wlb.tmsorder.query</td><td>通过物流订单编号查询物流信息</td><td>通过物流订单编号分页查询物流信息</td></tr><tr><td><br><br><br><br><br><br><br><br><br>库存</td><td>taobao.wlb.inventory.detail.get</td><td>查询库存详情</td><td></td></tr><tr><td></td><td>taobao.inventory.ipc.inventorydetail.get</td><td>库存明细查询</td><td></td></tr><tr><td></td><td>taobao.wlb.inventorylog.query</td><td>根据商品ID查询所有库存变更记录</td><td>通过商品ID等几个条件来分页查询库存变更记录</td></tr><tr><td></td><td>cainiao.merchant.inventory.adjust</td><td>商家库存调整</td><td>商家仓库存调整接口，目前仅支持全量更新</td></tr><tr><td></td><td>taobao.wlb.wms.inventory.lack.upload</td><td>缺货通知</td><td></td></tr><tr><td></td><td>taobao.wlb.wms.inventory.count</td><td>损益单回传</td><td></td></tr><tr><td></td><td>taobao.wlb.out.inventory.change.notify</td><td>外部库存变化通知</td><td>拥有自有仓的企业物流用户通过该接口把自有仓的库存通知到物流宝，由物流宝维护该库存，控制前台显示库存的准确性</td></tr><tr><td><br><br><br><br><br><br>其他</td><td>taobao.wlb.notify.message.confirm</td><td>通知消息确认</td><td>确认物流宝可执行消息</td></tr><tr><td></td><td>taobao.wlb.notify.message.page.get</td><td>通知消息查询接口</td><td>物流宝提供的消息通知查询接口，消息内容包括;出入库单不一致消息，取消订单成功消息，盘点单消息<br></td></tr><tr><td></td><td>taobao.uop.tob.order.create</td><td>ToB仓储发货</td><td></td></tr><tr><td></td><td>taobao.wlb.subscription.query</td><td>查询商家定购的所有服务</td><td>查询商家定购的所有服务,可通过入参状态来筛选</td></tr></tbody></table><p><a name="76cefffa-1"></a></p><h2 id="业务设计-1"><a href="#业务设计-1" class="headerlink" title="业务设计"></a>业务设计</h2><p>目前理解是物流宝向下对接WMS、TMS等实操系统，向上对接B端运营管理平台和商家<br>1.下图描述的是物流宝基于仓储、配送和服务能力的能力网络及其之上的服务网络和运营网络<img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1550818654415-90550364-8a44-4890-b1c3-e125c78e7f9f.png#align=left&amp;display=inline&amp;height=620&amp;name=image.png&amp;originHeight=1240&amp;originWidth=2422&amp;size=472071&amp;status=done&amp;width=1211" alt="image.png"><br>2.下图描述的是物流宝在能力、服务和运营网络之上建立服务平台、履行平台和跟踪平台；之下提供仓储平台和配送平台<img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1550819502419-cf1507df-bf27-4af0-bf38-a7bebf04de05.png#align=left&amp;display=inline&amp;height=456&amp;name=image.png&amp;originHeight=912&amp;originWidth=1438&amp;size=339952&amp;status=done&amp;width=719" alt="image.png"><br><a name="80d24a2a-1"></a></p><h2 id="借鉴意义-1"><a href="#借鉴意义-1" class="headerlink" title="借鉴意义"></a>借鉴意义</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1551748720905-3d0b230a-fcb1-4438-8d54-be2cfd395b81.png#align=left&amp;display=inline&amp;height=457&amp;name=image.png&amp;originHeight=914&amp;originWidth=1280&amp;size=303688&amp;status=done&amp;width=640" alt="image.png"><br>物流宝可以借鉴点在我看来是其服务于卖家、买家和第三方供应商的仓储、配送等资源协同平台，团队建设库存中心可以借鉴其对接WMS、TMS的仓储服务和配送服务建设上，例如：</p><ol><li>增强实物库存相关功能，为对接仓储管理和库存中心做准备</li></ol><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1551753207789-b143687b-0569-4685-b9d3-688faa3db52f.png#align=left&amp;display=inline&amp;height=411&amp;name=image.png&amp;originHeight=822&amp;originWidth=1280&amp;size=376025&amp;status=done&amp;width=640" alt="image.png"></p><ol><li>配送支持对接小件、大件、生鲜等包裹配送模式，商品运输支持大家电、小家电、商超等种类</li></ol><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1551753302357-1356a2c4-9c98-4072-aa25-1f7d1cc735f6.png#align=left&amp;display=inline&amp;height=289&amp;name=image.png&amp;originHeight=577&amp;originWidth=1280&amp;size=162369&amp;status=done&amp;width=640" alt="image.png"><br>参考资料<a href="https://yuque.antfin-inc.com/attachments/lark/0/2019/pptx/124729/1551689898487-e799faa4-acbb-4f52-bac5-c0e26941cfd7.pptx?_lake_card=%7B%22uid%22%3A%22rc-upload-1551689603143-3%22%2C%22src%22%3A%22https%3A%2F%2Fyuque.antfin-inc.com%2Fattachments%2Flark%2F0%2F2019%2Fpptx%2F124729%2F1551689898487-e799faa4-acbb-4f52-bac5-c0e26941cfd7.pptx%22%2C%22name%22%3A%22%E7%89%A9%E6%B5%81%E5%AE%9D%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D.pptx%22%2C%22size%22%3A3573899%2C%22type%22%3A%22application%2Fvnd.openxmlformats-officedocument.presentationml.presentation%22%2C%22ext%22%3A%22pptx%22%2C%22progress%22%3A%7B%22percent%22%3A0%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22card%22%3A%22file%22%7D" target="_blank" rel="noopener">物流宝平台介绍.pptx</a>、<a href="https://yuque.antfin-inc.com/inventorydistribution/mdp/bpgvgr" target="_blank" rel="noopener">https://yuque.antfin-inc.com/inventorydistribution/mdp/bpgvgr</a><br><a name="e57251dc"></a></p><h1 id="4-智分宝"><a href="#4-智分宝" class="headerlink" title="4.智分宝"></a>4.智分宝</h1><p><a name="8e1b944f-2"></a></p><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><p>智分宝起初主要是应用于中小件分拨中心的系统，随着业务发展，目前已经支持跨境出口业务、零售通业务、大件家装业务等。智分宝系统主要操作流程包括了：揽收、收货、集包、发货、交接等，操作流程如下图：<br><br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1552361031350-d2d00677-aa7f-47a8-821a-06572b823142.png#align=left&amp;display=inline&amp;height=191&amp;name=image.png&amp;originHeight=382&amp;originWidth=994&amp;size=76851&amp;status=done&amp;width=497" alt="image.png"><br><br><br><a name="8c40136d"></a></p><h2 id="主体业务环节"><a href="#主体业务环节" class="headerlink" title="主体业务环节"></a>主体业务环节</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1552878759456-bd86d99e-832a-4c82-b774-c8c25ace57e8.png#align=left&amp;display=inline&amp;height=601&amp;name=image.png&amp;originHeight=1202&amp;originWidth=1382&amp;size=257764&amp;status=done&amp;width=691" alt="image.png"><br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1552361283858-622f77b4-869d-4e04-bb05-dbfc084e07a3.png#align=left&amp;display=inline&amp;height=504&amp;name=image.png&amp;originHeight=1007&amp;originWidth=1095&amp;size=175855&amp;status=done&amp;width=548" alt="image.png"><br></p><ul><li><strong>收货</strong>类型分为运单收货和批量收货，其中批量收货指按集包维度收货，不用进行后续的分拣集包步骤，直接根据配置路由运转和调拨</li><li><strong>集包</strong>是将若干个包裹以一定的维度集合在特定的容器内，并赋予一定的业务含义</li><li><strong>交接</strong>是指包裹货物在集包后不需要再进行发货装车，下一步直接到仓库或者到配送站<br><a name="9bd5462f"></a><h2 id="平台化发展历史"><a href="#平台化发展历史" class="headerlink" title="平台化发展历史"></a>平台化发展历史</h2></li></ul><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1552361546344-a14ef428-e55d-41b6-bb6a-f325e4bf0a1a.png#align=left&amp;display=inline&amp;height=153&amp;name=image.png&amp;originHeight=305&amp;originWidth=1674&amp;size=182039&amp;status=done&amp;width=837" alt="image.png"><br><a name="76cefffa-2"></a></p><h2 id="业务设计-2"><a href="#业务设计-2" class="headerlink" title="业务设计"></a>业务设计</h2><ol><li>智分宝核心逻辑包含<strong>作业实操</strong>数据运营**两部分，边缘功能包含基础资料管理、用户设置和运输管理等</li><li>分拨中心<strong>作业实操功能</strong>，包括分拨运单，作业管理，列表管理，异常管理，交接单管理、打印管理和分拨管理等模块<ol><li>分拨运单包括包括分拨运单、分拨拦截、高级查询等功能</li><li>作业管理包括包括分拨收货、装车发货、分拨称重、称重记录等模块</li><li>列表管理包括包括集包列表、交接单列表等模块</li><li>异常管理包括异常登记、分拨换配等模块</li><li>交接管理包括交接单管理</li><li>打印管理包括集包批次打印、集包码补打、批次码补打、路由打印、面单打印等功能分拨管理包括包括分拨流向方案、分拨流向配置等模块</li></ol></li><li>分拨中心<strong>数据运营</strong>，包括各类数据报表，包括实时作业报表、统计作业报表、KPI考核报表、仓库生产情况、超时挂单数、分拨操作核对、人工分拣报表、分拨计划大盘、分拨大盘等模块</li></ol><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1552361759247-78f41271-5e0b-4049-bdb7-6cd2b4c0f93e.png#align=left&amp;display=inline&amp;height=440&amp;name=image.png&amp;originHeight=879&amp;originWidth=1186&amp;size=150695&amp;status=done&amp;width=593" alt="image.png"><br><br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1552527731127-2a91a5b5-01dc-44fb-9b84-0fd640c0468a.png#align=left&amp;display=inline&amp;height=323&amp;name=image.png&amp;originHeight=646&amp;originWidth=1178&amp;size=166852&amp;status=done&amp;width=589" alt="image.png"><br><a name="9005b835"></a></p><h2 id="正向操作"><a href="#正向操作" class="headerlink" title="正向操作"></a>正向操作</h2><p><a name="9344c97b"></a></p><h3 id="针对运单收货-公共分拨-的场景"><a href="#针对运单收货-公共分拨-的场景" class="headerlink" title="针对运单收货(公共分拨)的场景"></a>针对运单收货(公共分拨)的场景</h3><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1552461991687-ca419ef7-3d85-4d18-a74e-ca7a947785c2.png#align=left&amp;display=inline&amp;height=338&amp;name=image.png&amp;originHeight=675&amp;originWidth=1280&amp;size=61672&amp;status=done&amp;width=640" alt="image.png"><br><a name="ffedfd2b"></a></p><h3 id="针对批量收货-CP分拨-的场景"><a href="#针对批量收货-CP分拨-的场景" class="headerlink" title="针对批量收货(CP分拨)的场景"></a>针对批量收货(CP分拨)的场景</h3><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1552470204975-dc0854a0-80bc-405e-a8b5-af054cfecf95.png#align=left&amp;display=inline&amp;height=341&amp;name=image.png&amp;originHeight=681&amp;originWidth=1280&amp;size=41590&amp;status=done&amp;width=640" alt="image.png"><br><a name="54b6d620"></a></p><h2 id="逆向操作"><a href="#逆向操作" class="headerlink" title="逆向操作"></a>逆向操作</h2><p><a name="b9b2bbe5"></a></p><h3 id="针对配送时拒收的场景"><a href="#针对配送时拒收的场景" class="headerlink" title="针对配送时拒收的场景"></a>针对配送时拒收的场景</h3><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1552445552171-ec89750c-ffe0-49f9-be8c-6661ee1a7592.png#align=left&amp;display=inline&amp;height=338&amp;name=image.png&amp;originHeight=675&amp;originWidth=1280&amp;size=68157&amp;status=done&amp;width=640" alt="image.png"><br><br><a name="9a08a07d"></a></p><h3 id="针对退货时拦截登记的场景"><a href="#针对退货时拦截登记的场景" class="headerlink" title="针对退货时拦截登记的场景"></a>针对退货时拦截登记的场景</h3><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1552445626213-3cb23ea5-c366-4761-9beb-d55a4d74f1fe.png#align=left&amp;display=inline&amp;height=338&amp;name=image.png&amp;originHeight=675&amp;originWidth=1280&amp;size=68987&amp;status=done&amp;width=640" alt="image.png"><br><a name="80d24a2a-2"></a></p><h2 id="借鉴意义-2"><a href="#借鉴意义-2" class="headerlink" title="借鉴意义"></a>借鉴意义</h2><p>在分拨中心落地建设中，在设计分拣、集单模块时可以参考智分宝的设计思路，以及对正向和逆向操作流程的标准化，比较难的一块看下来应该是分拨规则计算(确定哪些货送上哪辆车)，要尽量装满车并且不会滞留过久。<br>参考资料：<a href="https://yuque.antfin-inc.com/cnlst/lstwl/bae34g" target="_blank" rel="noopener">https://yuque.antfin-inc.com/cnlst/lstwl/bae34g</a><br><a href="https://yuque.antfin-inc.com/zfbplatformproject" target="_blank" rel="noopener">https://yuque.antfin-inc.com/zfbplatformproject</a><br><a name="e36ddc0d"></a></p><h1 id="5-运保宝"><a href="#5-运保宝" class="headerlink" title="5.运保宝"></a>5.运保宝</h1><p><a name="d41d8cd9"></a></p><p>#</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;仓储库存作为全渠道零售的底层核心支撑业务，服务于整个交易链路，承担十分重要的作用。在学习公司已有parana_
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ActionChain定义笔记.md</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/ActionChain%E5%AE%9A%E4%B9%89%E7%AC%94%E8%AE%B0/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/ActionChain定义笔记/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><p><a name="889248f2"></a></p><h4 id="Action贯穿在库存交易操作，提供链式操作方便迭代扩展，将流程从代码实现逻辑中抽出提炼为标准，使用时通过指定action及顺序实现相关业务"><a href="#Action贯穿在库存交易操作，提供链式操作方便迭代扩展，将流程从代码实现逻辑中抽出提炼为标准，使用时通过指定action及顺序实现相关业务" class="headerlink" title="Action贯穿在库存交易操作，提供链式操作方便迭代扩展，将流程从代码实现逻辑中抽出提炼为标准，使用时通过指定action及顺序实现相关业务"></a>Action贯穿在库存交易操作，提供链式操作方便迭代扩展，将流程从代码实现逻辑中抽出提炼为标准，使用时通过指定action及顺序实现相关业务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionChain</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">ActionContext</span>&gt; <span class="keyword">implements</span> <span class="title">Appendable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//存储具体操作链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;IAction&lt;T&gt;&gt; chain = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//存储拦截器链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;IInterceptor&lt;T&gt;&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//添加具体操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Appendable&lt;T&gt; <span class="title">appendAction</span><span class="params">(Class&lt;? extends IAction&lt;T&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        chain.add(ActionBeanFactory.getActionInstance(action));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Appendable&lt;T&gt; <span class="title">appendInterceptor</span><span class="params">(IInterceptor&lt;T&gt; interceptor)</span> </span>&#123;</span><br><span class="line">        interceptors.add(interceptor);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//执行逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">execute</span><span class="params">(T context)</span> </span>&#123;</span><br><span class="line">        IAction&lt;T&gt; currentAction = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ActionResult actionResult = ActionResult.success();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!context.isIgnored() &amp;&amp; !context.isIdempotent() &amp;&amp; actionResult.isSuccess()</span><br><span class="line">                &amp;&amp; (currentAction = nextAction(currentAction)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                intercept(context, currentAction, actionResult, Stage.BEFORE, <span class="keyword">null</span>);</span><br><span class="line">                currentAction.execute(context);</span><br><span class="line">                intercept(context, currentAction, actionResult, Stage.AFTER, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                intercept(context, currentAction, actionResult, Stage.EXCEPTION, ex);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                intercept(context, currentAction, actionResult, Stage.FINAL, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        actionResult.forwardContextStatus(context.isIgnored(), context.isIdempotent());</span><br><span class="line">        <span class="keyword">return</span> actionResult;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">intercept</span><span class="params">(T param, IAction&lt;T&gt; handler, ActionResult result, Stage loc, Throwable ex)</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> Stage &#123;</span><br><span class="line">        BEFORE,</span><br><span class="line">        AFTER,</span><br><span class="line">        FINAL,</span><br><span class="line">        EXCEPTION</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="8e1ff949"></a></p><h4 id="在使用时主要通过实现IAction接口中execute-方法的action实现类、实现IInterceptor接口中beforeHandle-、afterHandle-、errorHandle-和finalHandle-方法的interceptor实现类和继承ActionContext的具体场景上下文完成逻辑编写实现"><a href="#在使用时主要通过实现IAction接口中execute-方法的action实现类、实现IInterceptor接口中beforeHandle-、afterHandle-、errorHandle-和finalHandle-方法的interceptor实现类和继承ActionContext的具体场景上下文完成逻辑编写实现" class="headerlink" title="在使用时主要通过实现IAction接口中execute()方法的action实现类、实现IInterceptor接口中beforeHandle()、afterHandle()、errorHandle()和finalHandle()方法的interceptor实现类和继承ActionContext的具体场景上下文完成逻辑编写实现"></a>在使用时主要通过实现IAction<t>接口中execute()方法的action实现类、实现IInterceptor<t>接口中beforeHandle()、afterHandle()、errorHandle()和finalHandle()方法的interceptor实现类和继承ActionContext的具体场景上下文完成逻辑编写实现</t></t></h4><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;&lt;a name=&quot;889248f2&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;h4 id=&quot;Action贯穿在库存交易操作，提供链式
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dice使用笔记.md</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/Dice%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/Dice使用笔记/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><ol><li>将本地代码依照git-flow格式要求推送到dice的gittar仓库中</li><li>在分析项目栏点击新建分支选择要打包的分支，点击提交后开始进入项目打包阶段，完成代码获取、打包类型识别、编译代码、制作 Docker 镜像几个步骤</li><li>等待过程中可以点击项目动态查看部署状态</li></ol><hr><p>实现功能小结：</p><ul><li>源码自动编译打包，添加dockerfile生成docker image上传至平台的repository</li><li>打包成功后，通过集群管理平台进行服务部署<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1546915237390-79885466-d6df-4d85-9268-6030016f4b2a.png" alt="结构"><ul><li>成功部署后界面如下图所示，实现了CI/CD基本要求<br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1546917270389-316d16c2-1d64-4875-9955-66f7c9412984.png" alt="Dice项目流水线"></li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;ol&gt;&lt;li&gt;将本地代码依照git-flow格式要求推送到dice的gittar仓库中&lt;/li&gt;&lt;li&gt;在分析项目
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>库存中心术语表.md</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/%E5%BA%93%E5%AD%98%E4%B8%AD%E5%BF%83%E6%9C%AF%E8%AF%AD%E8%A1%A8/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/库存中心术语表/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.719Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><p>1.<a href="[https://yuque.antfin-inc.com/terminus_inventory/xailob/phuvqm](https://yuque.antfin-inc.com/terminus_inventory/xailob/phuvqm">仓库名词解释</a>)<br>2.<a href="[https://yuque.antfin-inc.com/terminus_inventory/xailob/lpshsg](https://yuque.antfin-inc.com/terminus_inventory/xailob/lpshsg">基础业务名词</a>)<br>3.<a href="[https://yuque.antfin-inc.com/terminus_inventory/xailob/zs5p4r](https://yuque.antfin-inc.com/terminus_inventory/xailob/zs5p4r">菜鸟常用业务术语</a>)<br>4.GIS(Global inventory Service)<br>5.SCM(Supply Chain Management)<br>6.PO(purchase order)<br>7.CP(Content Provider)<br>8.BMS计费管理系统<br>9.TOM(Total Order Management)<br>10.LGMS是Lazada端的物流管理系统，提供一系列HTTP接口供菜鸟端调用，如仓储单状态有更新时，WHC需要调用LGMS接口来通知状态的更新<br>11.统一建模语言（UML）用例图</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;1.&lt;a href=&quot;[https://yuque.antfin-inc.com/terminus_inven
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>库存中心项目测试笔记.md</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/%E5%BA%93%E5%AD%98%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/库存中心项目测试笔记/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.719Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h2 id="inventory-server测试部分前提概要"><a href="#inventory-server测试部分前提概要" class="headerlink" title="inventory-server测试部分前提概要"></a>inventory-server测试部分前提概要</h2><ul><li>测试部分分开使用了TestNG和Junit测试框架，并且在Junit测试框架部分由于迭代开发由不同人员接手，导致包测试结构混乱，测试相同功能可能有多个测试类，后面的接手人员需要加以甄别</li><li>已经将不再使用的测试类使用@Deprecated注解标注，后面的接手人员可以忽略这些测试类带来的干扰</li><li>单元测试在sponge迭代中明确规定要达到工程行覆盖率80%的要求<h2 id="inventory-server测试TestNG部分原理"><a href="#inventory-server测试TestNG部分原理" class="headerlink" title="inventory-server测试TestNG部分原理"></a>inventory-server测试TestNG部分原理</h2></li><li>该部分使用io.terminus.parana.Generator通过相关配置自动生成测试目录结构，相关实现逻辑见<a href="https://yuque.antfin-inc.com/wb-xxy406417/hsmsiu/rug8cg" target="_blank" rel="noopener">测试自动化插件</a></li><li>目前这部分读取resources下的json资源文件作为请求参数，执行自动生成的dubbo接口测试类<h2 id="寻源InventorySourcingService单元测试备忘"><a href="#寻源InventorySourcingService单元测试备忘" class="headerlink" title="寻源InventorySourcingService单元测试备忘"></a>寻源InventorySourcingService单元测试备忘</h2></li><li>目前寻源部分单测行覆盖率由64%提高到84%，但执行inventory包下所有测试寻源部分并达不到80%原因待查;server下的sourcing模块重构自manager.component下的sourcing模块</li><li>寻源sourcingConfig加载要求tenantId必须存在且目前代码逻辑必须等于默认值1</li><li>寻源工作流使用了workflow包下定义的工作操作流，没有使用sourcing包下定义的SourcingActionChain定义的工作链</li><li>当前寻源测试覆盖了大多数业务场景，但代码中预置相关数据部分，只能使用注释中标出要插入的sql语句，无法在before中构造使用，原因是多线程寻源时不能提取事务中未提交的数据</li><li>beforeHandle包内的BucketWarehouseHandler对应的executor枚举值为bucketPreHandler</li><li>afterHandler包内的DefaultBucketAfterHandler针对海信的两条寻源规则单测没有覆盖到，需要开启XhsdBucketAssemble</li><li>preHandle内的WarehousePreHandler目前配置中未使用，需要构造新的SourcingConfig插入执行</li><li>selector内的EntityQuantityWarehouseSelector目前由于IndexWarehouse中的index为null部分逻辑单测覆盖不到</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;inventory-server测试部分前提概要&quot;&gt;&lt;a href=&quot;#inventory-serv
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>批次库存&amp;临保库存.md</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/%E6%89%B9%E6%AC%A1%E5%BA%93%E5%AD%98&amp;%E4%B8%B4%E4%BF%9D%E5%BA%93%E5%AD%98/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/批次库存&amp;临保库存/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.719Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h2 id="批次管理的主要用途是支持库存管理，方法是模拟商品的实物发生过程，给予出入库的记录，从而能够准确地进行库存的统计和管控。"><a href="#批次管理的主要用途是支持库存管理，方法是模拟商品的实物发生过程，给予出入库的记录，从而能够准确地进行库存的统计和管控。" class="headerlink" title="批次管理的主要用途是支持库存管理，方法是模拟商品的实物发生过程，给予出入库的记录，从而能够准确地进行库存的统计和管控。"></a>批次管理的主要用途是支持库存管理，方法是模拟商品的实物发生过程，给予出入库的记录，从而能够准确地进行库存的统计和管控。</h2><ul><li>在批次上，要能够识别该批次商品的进货时间、进货单单据号、供应商、进价等项目，这样就可以在后期查询库存时，明确商品的具体来源。</li><li>在批次上，要能够识别该批次商品的包装信息，包括包装规格、包装条形码等项目，这样在后期入库上架、出库等业务处理时，根据包装规格来进行计算。</li><li>在批次上，对于管理保质期的商品，要能够识别该批次商品的生产日期信息，包括生产日期、到期日期等项目，这样就可以在收货、配送出库、销售出库等业务处理时，自动判断商品保质期和保鲜期，并执行先进先出了。</li></ul><hr><p>根据以上对批次的可识别项目的要求，在定义一个批次时，一般商品要根据商品的进货单、进价、生产日期、包装规格等项目来进行区分，只要其中一个项目不同，就识别为不同的批次；对于特殊商品，则要根据特殊项目，如批号、序列号等，进一步区分批次。</p><h2 id="临保库存是指接近保质期的库存。不同的商品临保时间定义不一样。通过定义商品临保规则，计算临保商品是否进入临保时间段，同时提供报表能力。"><a href="#临保库存是指接近保质期的库存。不同的商品临保时间定义不一样。通过定义商品临保规则，计算临保商品是否进入临保时间段，同时提供报表能力。" class="headerlink" title="临保库存是指接近保质期的库存。不同的商品临保时间定义不一样。通过定义商品临保规则，计算临保商品是否进入临保时间段，同时提供报表能力。"></a>临保库存是指接近保质期的库存。不同的商品临保时间定义不一样。通过定义商品临保规则，计算临保商品是否进入临保时间段，同时提供报表能力。</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1547602114381-a357978d-7fad-4b4d-9467-85c693f2c581.png" alt="功能描述"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;批次管理的主要用途是支持库存管理，方法是模拟商品的实物发生过程，给予出入库的记录，从而能够准确地进行
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新零售库存模型笔记.md</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/%E6%96%B0%E9%9B%B6%E5%94%AE%E5%BA%93%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/新零售库存模型笔记/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.719Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><ul><li>盒马新零售库存模型(一盘货)将库存分为四类，分别是面向C端消费者的销售库存GSI、面向B端业务层的业务库存GBI、面向财务管理的财务库存GAI和面向采购供应链的实物库存GPI。</li><li>门店库存和仓库库存在2019.02.18阶段总结会议中@太丘(taiqiu) 指出在IPM层面应该抽象成为一样的模型来看待；中央库存的概念可以在现有库存模型中添加适配层来实现，<a href="https://yuque.antfin-inc.com/inv" target="_blank" rel="noopener">集团内部库存中心lark文档</a></li><li>集团库存中心架构图<img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1550567747143-b487c26f-f8f7-4eb2-9f0e-08cba3208af9.png" alt="库存业务架构"></li><li>海信库存中心的库存类型分为：共享库存、独占库存、虚拟库存和在途库存</li><li>天猫库存模式分为：普通前端模式(前端item库存、前端sku库存、门店库存、批次库存等)；分销虚仓模式(后端item库存)；区域限售模式(基于地址/经纬度等)；商家仓模式；门店自提模式<img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1550570132568-ab330851-b0f5-4bc3-b6cf-6bad292e502e.png" alt="部署架构"></li><li><a href="https://yuque.antfin-inc.com/cnwmsinventory/ndwb5k/gd2k8p" target="_blank" rel="noopener">菜鸟库存模型</a>将库存分为基础网络库存、逻辑库存和物理库存，在已有概念里主要作为WMS存在，主要关注仓储业务。模型整体定义为GIS(global inventory service)全球库存服务，提供的接口如下：<img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1550715477634-5b71ad20-7394-4685-b634-cfb5714a6575.png" alt="GIS服务接口"><br>业务结构如下：<img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1550720059123-9050293f-6ca8-4ec5-adf6-d19079827003.png" alt="gis"></li><li>奇门仓储支持的业务背景如下，处于承上启下的位置来对接ERP/OMS等、WMS<img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1550732374568-e456fb0f-d257-4221-ade5-bb5b35de7e0c.png" alt="作用"></li><li><a href="https://yuque.antfin-inc.com/fanghui.lfh/gbo5o1/dx1sid" target="_blank" rel="noopener">物流宝3.0</a>以物流服务为核心，主要包含服务路由、订单中心、发货、接入平台、订购、结算平台等业务单元，架构图如下：<img src="https://cdn.yuque.com/lark/0/2018/png/17147/1528521818972-0a5a9f82-2c8d-4045-a38a-8c65aa528d19.png" alt="wuliubao"></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;ul&gt;&lt;li&gt;盒马新零售库存模型(一盘货)将库存分为四类，分别是面向C端消费者的销售库存GSI、面向B端业务层的业
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WorkFlow定义笔记.md</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/WorkFlow%E5%AE%9A%E4%B9%89%E7%AC%94%E8%AE%B0/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/WorkFlow定义笔记/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h1 id="工作流workfow定义"><a href="#工作流workfow定义" class="headerlink" title="工作流workfow定义"></a>工作流workfow定义</h1><h2 id="节点node定义"><a href="#节点node定义" class="headerlink" title="节点node定义"></a>节点node定义</h2><ul><li>StartNode 起始节点</li><li>TaskNode 任务节点</li><li>ForkNode 分支节点</li><li>JoinNode 合并节点</li><li>EndNode 结束节点<h2 id="控制方法定义"><a href="#控制方法定义" class="headerlink" title="控制方法定义"></a>控制方法定义</h2></li><li>start 初始化workflow</li><li>next 添加任务</li><li>decision 判断逻辑</li><li>fork 分支</li><li>or 或</li><li>join 合并</li><li>end 结束workflow<h2 id="workflow-基本常识"><a href="#workflow-基本常识" class="headerlink" title="workflow 基本常识"></a>workflow 基本常识</h2></li><li>fork后必须有唯一的join与其对应</li><li>fork和join应该提供多线程支持提高执行效率</li><li>ForkNode记录各分支Node</li><li>JoinNode记录被合并的各分支Node</li><li>fork()或decision()后不可以立刻跟join(),需要有至少一个or()</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;工作流workfow定义&quot;&gt;&lt;a href=&quot;#工作流workfow定义&quot; class=&quot;heade
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>库存寻源业务逻辑梳理.md</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/Sourcing%E5%AF%BB%E6%BA%90%E6%A8%A1%E5%9D%97%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/Sourcing寻源模块业务逻辑整理/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h4 id="寻源业务场景"><a href="#寻源业务场景" class="headerlink" title="寻源业务场景"></a>寻源业务场景</h4><ul><li>商品详情页查看当前区域商品可售数量<ul><li>直降活动库存大于实际可售库存，详情页查询要以实际可售库存为准</li><li>直降活动库存小于实际可售库存，详情页查询要以直降活动库存为准</li><li>区域限购无可售库存</li></ul></li><li>商品购物车<ul><li>在商品已经加入购物车后，由于库存数量改变导致不满足购物车条件要提示库存不足</li><li>在商品加入购物车后，切换配送地址要及时反馈不可售情况</li></ul></li><li>单sku下单<ul><li>预售活动库存小于仓库实际库存，按照仓库优先级扣减库存，在单sku下单数量高于实际库存时提示无法购买</li><li>但仓库数量不满足下单sku数量时拆单规则要符合仓库优先级设置</li></ul></li><li>一个商家多个sku下单<ul><li>普通场景下尽量在仓库优先级设置下要以同一仓库发货为准</li><li>组合商品数量在任何仓库都不满足同一仓库出库的前提下提示不可售</li></ul></li><li>买赠场景<ul><li>买商品A赠商品B在寻源时配置优先级</li><li>买A赠C &amp; 买B赠A默认遵循赠品优先于主商品的逻辑<h4 id="寻源核心逻辑"><a href="#寻源核心逻辑" class="headerlink" title="寻源核心逻辑"></a>寻源核心逻辑</h4><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1547016084904-46fe3085-8264-4e26-b396-4c0e1c00eb54.png" alt="寻源流程图"><br><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1551771097372-46431d8f-61fa-4add-b12d-9bdb978450b1.png" alt="包结构"><br><em>v5.0.18.1.RELEASE</em>寻源基于工作流的方式进行<ol><li><strong>sourcing prehandler</strong>: 寻源参数预处理，主要分为以下四个步骤</li></ol><ul><li>io.terminus.parana.inventory.server.sourcing.prehandle.support.DivisionValidator 实现仓库配送范围参数校验，针对不配送区域直接返回</li><li>io.terminus.parana.inventory.server.sourcing.prehandle.support.SourcingRuleLoad 主要是寻源规则的加载并处理，如配置是否必须同仓出货等</li><li>io.terminus.parana.inventory.server.sourcing.prehandle.support.SourcingQuantityPreHandler 控制NPE，将寻源的商品数量&lt;=0的设置为1</li><li>io.terminus.parana.inventory.server.sourcing.prehandle.support.WarehousePrehandler 仓库相关预处理，剔除不符合要求的一部分</li></ul></li></ul></li></ul><ol start="2"><li><p><strong>assemble bucket</strong>：组装组合商品，进行商品及数量的合并, 默认提供io.terminus.parana.inventory.server.sourcing.bucket.support.DefaultBucketAssemble支持相关逻辑，内部经由group()、combineSameSku()和handleOutingRule()处理后将SourcingBuckets存入payload中</p></li><li><p><strong>bucket sourcing</strong>：寻源的主要逻辑</p><ul><li>bucket initial process: 初步过滤，默认提供BucketWarehouseHandler中处理针对入参的仓库集和寻源规则，区域限售针对仓库的过滤等</li><li>data load：寻源的数据加载，加载Inventory-&gt;加载渠道库存-&gt;处理仓库维度独占问题-&gt;加载warehouse</li><li>warehouse filter：二次仓库过滤，合并仓库，去掉warehouse中的inventory</li><li>check quantity: 计算最大可贩卖库存，默认提供DefaultCheckQuantity实现主要逻辑</li><li>satisfied warehouse selector: 针对库存不满足需求的仓库进行过滤，默认提供DefaultWarehouseSelector和EntityQuantityWarehouseSelector实现主要逻辑</li><li>bucket special process: 出库特殊处理，对于不能被workflow接下来逻辑影响的策略要提前进行处理，针对海信的有货即发，必须同仓以上两个寻源规则，海信不需要考虑最小拆仓原则，优先在bucket处理掉</li></ul></li><li><p><strong>combine warehouse</strong>: 针对不同的业务合并仓库,默认提供io.terminus.parana.inventory.server.sourcing.combination.support.DefaultWarehouseReCombination支持相关逻辑，将满足条件的仓库合并成CombinedWarehouseExt列表存储在payload中</p></li><li><p><strong>sort warehouse</strong>: 过滤仓库，默认提供DefaultWarehouseSort内部通过Comparator的选择实现主要逻辑</p><ul><li>MatchedComparator：根据仓库命中数排序，命中数越高排名越前</li><li>IndexComparator：根据仓库index排序，index值越小排名越前</li><li>QuantityComparator：根据仓库可卖sku数量排序，数量越多排名越前</li></ul></li><li><p><strong>choose best warehouse</strong>：选择最优仓库，默认提供DefaultWarehouseChoose实现主要逻辑</p></li></ol><p>上述所有操作都是可配置化的，在业务层面建立SourcingConfig注入到Spring中，利用策略模式选择合适的处理策略，配合责任链模式和命令模式实现具体功能。</p><h4 id="寻源多线程相关"><a href="#寻源多线程相关" class="headerlink" title="寻源多线程相关"></a>寻源多线程相关</h4><p>1.多线程执行parallelExecution用于经过preHandler和AssembleBucket处理之后的核心部分<strong>bucketSourcing</strong>中<br>2.接口定义如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParallelExecution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ParallelExecutionAction action, ParallelExecutionContext context, Collection&lt;? extends ParallelExecutionParam&gt; collection)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>内部通过使用CountDownLatch实现多线程并发，实际调用：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParallelServiceTemplate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Response&lt;T&gt; <span class="title">executeParallel</span><span class="params">(ParallelServiceCallback&lt;T&gt; callback)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在ParallelServiceTemplateImpl中调用定义的注解@ParallelExecute标注的ParallelAction.executeAction()在切面ParallelExecuteUtility执行实际多线程业务<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(value = <span class="string">"@annotation(parallelExecute)"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ProceedingJoinPoint joinPoint, ParallelExecute parallelExecute)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   joinPoint.proceed(parameters);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                   callback.setEx(throwable);</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   callback.getCountDownLatch().countDown();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="寻源服务接口io-terminus-parana-inventory-server-sourcing-InventorySourcingService"><a href="#寻源服务接口io-terminus-parana-inventory-server-sourcing-InventorySourcingService" class="headerlink" title="寻源服务接口io.terminus.parana.inventory.server.sourcing.InventorySourcingService"></a>寻源服务接口<em>io.terminus.parana.inventory.server.sourcing.InventorySourcingService</em></h4><pre><code class="java"><span class="comment">//首先在阅读源码过程中，该接口实现类有几点我觉得是在技术实现上是可以改进的</span><span class="comment">//1.下面的代码中SourcingResultExecutor在逻辑中单独注入运行，为什么不添加到WorkflowBuilder</span><span class="comment">//后放入Workflow中执行，单独提出来的原因在源码中没看出来，觉得可能是原始代码是不同人接手完成的</span><span class="keyword">try</span> {            log.info(<span class="string">"sourcing begin ,param:{}"</span>, JSON.toJSON(sourcingParam));            WorkFlow&lt;InventorySourcingByDimension, Payload&gt; workFlow = workflowBuilder.build(sourcingParam);            payload = createPayLoad(sourcingParam, tenantId);            payload.setWorkFlow(workFlow);            workFlow.exec(sourcingParam, payload);        } <span class="keyword">catch</span> (SourcingException e) {            log.error(<span class="string">"inventory.sourcing.fail"</span>, e);        } <span class="keyword">catch</span> (Exception e) {            log.error(<span class="string">"inventory.sourcing.fail"</span>, e);        }        sourcingResultExecutor.execute(sourcingParam, payload);        InventorySourcingByDimension sourcingResult = payload.getSourcingResult();<span class="comment">//2.捕捉异常SourcingException和Exception报错信息相同的话合并下是不是更好</span><span class="comment">//3.寻源service没有使用接口定义，直接在service类中写了Implement实现逻辑</span></code></pre><h4 id="工作流中主要参数InventorySourcingByDimension、InventoryBucket和Payload"><a href="#工作流中主要参数InventorySourcingByDimension、InventoryBucket和Payload" class="headerlink" title="工作流中主要参数InventorySourcingByDimension、InventoryBucket和Payload"></a>工作流中主要参数<em>InventorySourcingByDimension</em>、<em>InventoryBucket</em>和<em>Payload</em></h4><ul><li><strong>InventorySourcingByDimension</strong> 被库存服务接口唯一参数inventorySourcing内数组包装，包含寻源dto列表sourcingInventories、维度dimensionId、维度类型dimensionType、区域divisionIds、仓库信息warehouses、寻源选项sourcingOption等字段</li><li><strong>Payload</strong> 包含业务id、工作流workflow、<strong>InventorySourcingByDimension</strong>、bucketList、寻源各个节点配置sourcingConfig、排序过的寻源规则优先级sortedSourcingRules、寻源返回值sourcingResult等字段</li><li><strong>InventoryBucket</strong> 库存捆绑信息是寻源的基础，来源于<strong>Payload</strong>中的bucketList计算赋值的寻源库存集合内，包含仓库库存是否满足satisfied、满足数量要求的仓库列表warehouseResult、该bucket使用的寻源规则列表sourcingRules、出库规则outingRule等字段<h4 id="工作流实现类和寻源工作流实现类DefaultWorkflowBuilder-amp-DefaultSourcing"><a href="#工作流实现类和寻源工作流实现类DefaultWorkflowBuilder-amp-DefaultSourcing" class="headerlink" title="工作流实现类和寻源工作流实现类DefaultWorkflowBuilder&amp;DefaultSourcing "></a>工作流实现类和寻源工作流实现类<em>DefaultWorkflowBuilder&amp;DefaultSourcing</em></h4></li><li>DefaultWorkflowBuilder定义了PreSourcingHandleExecutor-&gt;BucketAssembleExecutor-&gt;<strong>SourcingExecutor</strong>-&gt;WarehouseCombinationExecutor-&gt;WarehouseSortExecutor-&gt;WarehouseChooseExecutor工作流程</li><li>DefaultSourcing则将<strong>SourcingExecutor</strong>细分为BucketBeforeHandlerExecutor-&gt;DataloadExecutor-&gt;DefaultWarehouseFilterExecutor-&gt;DefaultCheckQuantityExecutor-&gt;WarehouseSelectExecutor-&gt;BucketAfterHandlerExecutor工作流程<h4 id="寻源执行实现类io-terminus-parana-inventory-server-sourcing-AbstractSourcingExecutor"><a href="#寻源执行实现类io-terminus-parana-inventory-server-sourcing-AbstractSourcingExecutor" class="headerlink" title="寻源执行实现类io.terminus.parana.inventory.server.sourcing.AbstractSourcingExecutor"></a>寻源执行实现类<em>io.terminus.parana.inventory.server.sourcing.AbstractSourcingExecutor</em></h4></li><li>实现了Executor接口的execute()方法，内部通过Payload.getSourcingConfig().getActionConfig()获取负载参数集中Action枚举值与寻源扩展处理类的映射关系，再迭代执行定义的抽象方doExecute(bean,param,payload)实现主要逻辑。</li><li>定义了protected List<t>extendClass(Payload payload）获取extend扩展类列表</t></li><li>义了protected List<string>extendClassName(Payload payload）获取extend扩展类名称</string></li><li>定义了抽象方法protected abstract void doExecute(T bean,P param,Payload payload）供实现类编写执行逻辑</li><li>定义了抽象方法protected abstract SourcingConfig.ActionEnum action(）获取Action枚举值</li><li>定义了抽象方法public abstract Class<t>ExtendClass(）与Action枚举值对应的Action接口</t></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h4 id=&quot;寻源业务场景&quot;&gt;&lt;a href=&quot;#寻源业务场景&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>巨人计划项目备忘录.md</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/%E5%B7%A8%E4%BA%BA%E8%AE%A1%E5%88%92%E9%A1%B9%E7%9B%AE%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/巨人计划项目备忘录/</id>
    <published>2019-04-03T06:31:47.000Z</published>
    <updated>2020-07-05T14:45:36.719Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h2 id="项目关键词"><a href="#项目关键词" class="headerlink" title="项目关键词"></a>项目关键词</h2><p>BRD 商业需求文档<br>MRD 市场需求文档<br>PRD 产品需求文档</p><h2 id="mockito配合Junit对restful接口进行测试"><a href="#mockito配合Junit对restful接口进行测试" class="headerlink" title="mockito配合Junit对restful接口进行测试"></a>mockito配合Junit对restful接口进行测试</h2><ol><li>首先在标记@before的init()方法中执行MockitoAnnotations.initMocks(this);开启@Mock注解</li><li>利用Spring的ReflectionUtils工具类中的getField()、makeAvailable()和setField()注入mock的类之间的依赖关系</li><li>通过when().thenReturn()方法为mock的注入类定制返回值</li><li>通过when().thenCallRealMethod()方法执行要测试的restful接口方法</li><li>通过when().thenThrow()方法模拟抛出异常的情况满足单元测试行覆盖率要求<h2 id="云效平台操作日志"><a href="#云效平台操作日志" class="headerlink" title="云效平台操作日志"></a>云效平台操作日志</h2></li><li>新建企业</li><li>新建项目</li><li>新建应用</li><li>新建流水线<h2 id="订单履约平台概述"><a href="#订单履约平台概述" class="headerlink" title="订单履约平台概述"></a>订单履约平台概述</h2><ul><li>从交易同步订单</li><li>创建履约单</li><li>正向订单履约和逆向订单履约</li><li>根据订单履约事件或操作，更新履约单状态</li><li>同步履约单状态给交易订单</li><li>履约单查询、导出、报表页面交互等<h2 id="LazadaFBL模式"><a href="#LazadaFBL模式" class="headerlink" title="LazadaFBL模式"></a>LazadaFBL模式</h2><img src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/124729/1553592986874-bc84e29d-b08d-4e05-b380-8292701bf784.png" alt="fbl"><h2 id="TBDlist"><a href="#TBDlist" class="headerlink" title="TBDlist"></a>TBDlist</h2></li></ul></li><li><del>订单履约系统架构图</del></li><li>表结构四月底前定到表</li><li>接口设计四月底前忽略</li><li><del>详细设计中四月底前覆盖重点模块和场景设计</del></li><li><del>概要设计中用例图</del><h2 id="03-29会议纪要"><a href="#03-29会议纪要" class="headerlink" title="03.29会议纪要"></a>03.29会议纪要</h2></li><li>梳理混合配送、预约/预购寻源逻辑</li><li>对供应链库存中退货部分进行领域图划分</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h2 id=&quot;项目关键词&quot;&gt;&lt;a href=&quot;#项目关键词&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二月总结</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/%E4%BA%8C%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/二月总结/</id>
    <published>2019-04-03T06:25:47.000Z</published>
    <updated>2020-07-05T14:45:36.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><h1 id="02-18"><a href="#02-18" class="headerlink" title="02.18"></a>02.18</h1><p>​ 总结库存中心已有能力内容、迭代一添加内容(仓库容量和仓库经纬度、批次库存和临保库存)以及迭代二拟添加内容(寻源产品化、共享渠道库存和渠道预设库存)<br><a href="/taiqiu">@太丘(taiqiu)</a>纠正仓库容量应为仓库每天可以处理的订单量而不是物理仓库容量；纠正批次库存应是服务于临保库存的，在模型领域不应该包括颜色、正残等sku信息；纠正迭代一输出图示中的仓库领域覆盖范围设置和派送规则设置应合并为一个设置<br>​ 讨论中 <a href="/taiqiu">@太丘(taiqiu)</a> 对Marathon迭代二寻源产品化实现要精简原理、迭代中不采用较为复杂的规则引擎，目前没有案例不要去做；在门店库存的概念上在做ipm时不应该单独提出来做，因为如果是wms则应区分门店和仓库，对于ipm则不透出门店库存与仓库库存的区别；库存适配平台不覆盖实物库存层，只提供适配层调用ERP也好、WMS也好甚至是门店和仓库，并且解决超卖问题和效率问题是关注点，快速适配各个平台不是主要关注点<br>​ 在做库存中心时要先屡清楚基础概念，仓库管理、库存量和与之对接的wms和渠道要区分清楚，采购供应链不在库存中心覆盖范围之内，可以先把大模块全部定义出来，提供可扩展性尽量达到以不变应万变的层级</p><h1 id="02-20"><a href="#02-20" class="headerlink" title="02.20"></a>02.20</h1><p>​ 会中团队人员各自分享了各自目前学习到的内容和困惑， <a href="/mingxu.ymx">@真青(mingxu.ymx)</a>指出<a href="/ym186904">@苏菁(ym186904)</a><a href="/yp195446">@禾佳(yp195446)</a><a href="/wb-xxy406417">@徐秀洋(wb-xxy406417)</a>在学习业务背景的同时要注重技术的熟练度，主要配合自动化测试工作等；</p><p>​ <a href="/weili.gwl">@高维立(weili.gwl)</a><a href="/nw181207">@见至(nw181207)</a>主要负责设计及框架建设。<br>会中提出的做产品要能够以不变应万变，将新需求套入已有模型中实现；熟悉菜鸟、物流宝、奇门仓储的API与区别,试问自己为什么存在这些名词看似相似的产品，保证自己在阿里产品海洋中不会迷失，能够聚焦到与自己学习思路相关的部分，主要关注<strong>仓储</strong>和<strong>配送</strong>的部分。<br>​ 会中确定从第九周开始Marathon第二次迭代，02.22召开会议确定迭代二内容。</p><h1 id="02-22"><a href="#02-22" class="headerlink" title="02.22"></a>02.22</h1><p>​ Tips：CRUD操作中只有R是安全的，U是不幂等的<br>​ 迭代二行动代号定为：sponge，迭代负责人为@于敏<br>​ 1.会议确认下次迭代中要将项目已有和新建业务层代码行覆盖率都要提高达到80%，单元测试的意义不是为了单纯完成指标，而是为了在将来重构时提供依据，承担库存相关业务单测补全。<br>​ 2.会议确认@于敏负责仓网络服务调研，@高维立负责渠道智能(基于海信)及奇门仓储服务调研，@倪炜负责菜鸟仓配服务调研，@殷鹏由于参与能力中心其他团队开发工作主要负责梳理库存占用、库存锁定和库存寻源逻辑输出文档工作<br>​ 3.会议强调要看代码中多线程使用场景及原因，为库存重构准备，并且讨论了多线程进行库存占用等操作的好处及弊端，从中我学到了可以在提高并发量的基础上放弃一定的事务性，使用回补等补偿措施以提高QPS</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;h1 id=&quot;02-18&quot;&gt;&lt;a href=&quot;#02-18&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="alicloud" scheme="https://masterx0.github.io/blog/categories/alicloud/"/>
    
    
      <category term="月度会议总结" scheme="https://masterx0.github.io/blog/tags/%E6%9C%88%E5%BA%A6%E4%BC%9A%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一月总结</title>
    <link href="https://masterx0.github.io/blog/2019/04/03/%E4%B8%80%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>https://masterx0.github.io/blog/2019/04/03/一月总结/</id>
    <published>2019-04-03T06:16:42.000Z</published>
    <updated>2020-07-05T14:45:36.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --><p>#1. whc模型<br>增加地址、经纬度？yes<br>仓库类型模型是否需要沉淀？ 01.08会议讨论<br>配送方式、配送规则与仓库模型之间是否需要通用规则模型去覆盖？<br>仓库容量？</p><p>#2. ipm模型<br>库存事件 mapping<br>临保库存、批次库存方案<br>库存事件状态机配置化</p><p>#3. 渠道channel<br>共享渠道库存 渠道预设库存 ？01.08会议讨论暂时不在迭代版本中cover</p><p>#4. 主要讨论库存落地技术方案讨论<br>迭代计划主要是库存和仓库两部分，渠道本次迭代暂不涉及<br>仓库</p><pre><code>- 仓库模型：仓库类型要符合行业背景，目前仓库类型是从东购中提取出来的四部分（当日配、供应商配送、直配送、入库配送）- 仓库添加经度和纬度属性，在创建仓库时由请求参数赋值实现; ps寻源逻辑需要cover- 库存容量：根据sku的type/体积做sum~~,与库存计划相关~~库存- 临保库存：指即将过期的商品库存，通过定义临保规则inventory_period_rule计算判断，隶属于批次库存- 批次库存：主要存储批次号、生产日期、过期日期、保质期和~~供应商~~等，良残品率是否记录?定义批次扣减规则- 渠道库存、共享库存方案未出库存事件配置化- 配置库存变化涉及的步骤（锁定、占用、扣减confirm和取消等），目前是写死在逻辑里的（例如：锁定-&gt;占用-&gt;扣减）Google做一个产品的顺序：1. 写新闻稿2. 写FAQ3. 写用户文档4. Coding</code></pre><p>#5.技术方案一审</p><ul><li>共享渠道库存实现逻辑讨论，现有版本没有cover这个功能，在实现中主要考虑预防超卖的问题，讨论出的方案是提供提供接口供调用者访问，在共享库存中的渠道商调用后扣减共享库存量，该能力保证共享渠道总库存量根据接口访问实时调整,经研究后目前接口已经提供但实现中未考虑相关业务场景</li><li>迭代计划讨论，主要分为渠道、库存、仓库三个模块，项目预提测时间1.25，上线日期1.29。<ul><li>仓库部分功能点有<strong>经纬度改造</strong>、<strong>库容模型</strong>、对接地址中心(可能不在迭代计划内)</li></ul></li><li>库存部分功能点有<strong>批次库存</strong>、<strong>临保库存</strong><ul><li>渠道部分功能点有共享渠道库存(可能不在迭代计划内)</li><li>批次库存&amp;临保库存<ul><li>提供批次CRUD、批次库存CRUD、临保规则CRUD、临保库存CRUD</li><li>临保库存是在批次库存的基础上通过定时任务或MQ等方式进行计算存储到DB所得的</li><li>临保库存目前设计仅限于保质期场景，技术方案二审拟改为更加通用的方案</li></ul></li><li>仓库经纬度&amp;库容<ul><li>提供根据指定位置获取最近的仓库</li><li>提供库容CRUD</li></ul></li><li>库存事件配置化<ul><li>待技术方案二审确定</li></ul></li></ul></li><li>技术方案二审<ul><li>批次库存在dimension_json中扩展出库规则满足后续扩展需要</li><li>临保库存暂时仍按一审会议安排</li><li>仓库经纬度和库容均为改造现有仓库模型内容</li><li>库存事件配置化</li><li>确定开发工作内容分配<ul><li>个人工作内容如下：临保规则CRUD、临保规则计算、临保数据CRUD、临保数据展示</li></ul></li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 05 2020 14:45:50 GMT+0000 (Coordinated Universal Time) --&gt;&lt;p&gt;#1. whc模型&lt;br&gt;增加地址、经纬度？yes&lt;br&gt;仓库类型模型是否需要沉淀？ 01.08会议讨论&lt;br
      
    
    </summary>
    
      <category term="alicloud" scheme="https://masterx0.github.io/blog/categories/alicloud/"/>
    
    
      <category term="月度会议总结" scheme="https://masterx0.github.io/blog/tags/%E6%9C%88%E5%BA%A6%E4%BC%9A%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
